# Copyright (c) 2010 cycad <cycad@greencams.net>. All rights reserved.

# todo: bot.disconnect() and clean the interface between core disconnections and higher level disconnections

import socket, sys, struct, ctypes, random, array, select, os, hashlib
import SubspaceCoreStack
from SubspaceCoreStack import GetTickCountHs, TickDiff, CoreStack, PRIORITY_HIGH, PRIORITY_NORMAL

EVENT_TICK = 1
"""Occurs every 1/10th of a second.

Sets: type"""

EVENT_DISCONNECT = 2
"""Occurs when the bot disconnects from the server.

Sets: type"""

EVENT_LOGIN = 3
"""Occurs when the bot logs in to the server.

At this point, commands and messages can be sent with success.  If the bot needs
to run any commands automatically on login, this is the time to do that.

Sets: type"""

EVENT_MESSAGE = 4
"""Indicates the bot received a message.

message is the text of the message.  message_type indicates what type of message
was received, and is one of the MESSAGE_TYPE_Xxx constants.

Sets: type, message, message_type"""

EVENT_ENTER = 5
"""Indicates a player entered the arena.

player is the player who entered.

A bot will receive an enter event for itself, so to avoid taking action on the
bot check event.player.pid against bot.pid.

Sets: type, player"""

EVENT_LEAVE = 6
"""Indicates a player left the arena.

player is the player who left.

Sets: type, player"""

EVENT_CHANGE = 7
"""Happens when a player changes ship, freq, or both.

player is the player that changed freq.  old_freq is the player's old frequency.
old_ship is the player's old ship. If {freq,ship} didn't change, old_{ship,freq}
are equal."""

EVENT_COMMAND = 8
"""A command was used.

player is the player that used the command.

command is the Command object that was used.  arguments are an array, starting
at the first argument.  arguments_after is an array of an argument and everything
after it, starting at the first argument. If there are no arguments passed,
arguments and arguments_after are empty lists.

For example after the command: !command a b c
   arguments = ['a', 'b', 'c']
   arguments_after = ['a b c', 'b c', 'c']
   
This allows you to match players with spaces in their name such as:
	!lag C H E E P
by using arguments_after[0]
   
Sets: type, player, command, arguments, arguments_after."""

EVENT_POSITION_UPDATE = 9
"""A position update was received for player.

Sets: type, player"""

EVENT_KILL = 10
"""A kill event was set.

killer is the player who did the killing, killed is the player who died.

Sets: type, killer, killed"""

EVENT_ARENA_LIST = 11
"""An arena list was received.  This is usually in response to sending a pub message
containing '?arena'.

arena_list is a list of (arena_name, num_players) tuples.

bot.arena is updated during this event.

Sets: type, arena_list"""

EVENT_TIMER = 12
"""A timer has expired.

id is the ID of the timer, returned by bot.setTimer(), of the timer that expired.
user_data is the same user_data passed to bot.setTimer() during the timer's creation.

Timers are only granular to 1 second.

Sets: type, id, user_data"""

EVENT_GOAL = 13
"""A goal was scored.

freq is the frequency the goal was scored by.
points is the amount of points rewarded to the freq by scoring a goal.

This event has no associated PID with it.

Sets: type, freq, points"""


COMMAND_TYPE_PUBLIC = 0
COMMAND_TYPE_PRIVATE = 1

FREQ_NONE = 0xFFFF

PID_NONE = 0xFFFF

SOUND_NONE = 0

MESSAGE_TYPE_ARENA = 0x00
"""An arena message (unsourced green)."""
MESSAGE_TYPE_PUBLIC_MACRO = 0x01
"""A public macro message (blue)."""
MESSAGE_TYPE_PUBLIC = 0x02
"""A public message (blue)."""
MESSAGE_TYPE_TEAM = 0x03
"""A team message (yellow)."""
MESSAGE_TYPE_FREQ = 0x04
"""A freq message (green name, blue text)"""
MESSAGE_TYPE_PRIVATE = 0x05
"""A private message (sourced green, in-arena)."""
MESSAGE_TYPE_WARNING = 0x06
"""A warning message from \*warn."""
MESSAGE_TYPE_REMOTE = 0x07
"""A remote message (sourced green, out of arena."""
MESSAGE_TYPE_SYSOP = 0x08
"""A sysop message (dark red)."""
MESSAGE_TYPE_CHAT = 0x09
"""A chat message (red)."""

SHIP_WARBIRD = 0
SHIP_JAVELIN = 1
SHIP_SPIDER = 2
SHIP_LEVIATHAN = 3
SHIP_TERRIER = 4
SHIP_WEASEL = 5
SHIP_LANCASTER = 6
SHIP_SHARK = 7
SHIP_SPECTATOR = 8

STATUS_STEALTH = 0x01
STATUS_CLOAK = 0x02
STATUS_XRADAR = 0x04
STATUS_ANTIWARP = 0x08
STATUS_FLASHING = 0x10
STATUS_SAFEZONE = 0x20
STATUS_UFO = 0x40

class GameEvent:
	"""Represents an event generated by the core."""
	
	type = None
	"""Is one of EVENT_Xxx."""
	
	def __init__(self, type):
		self.type = type
		
class Player:
	"""A class that represents the a Player.  All values are read-only to bots except
	for the 'player_info' variable that is reserved for bot's per-player data storage.
	
	The x_pos, y_pos, x_vel, y_vel, and status_Xxx are only as recent as the last_pos_update_tick
	timestamp.  Position updates are only received for players on the bot's radar, except
	in the case where a player first enters a safe area."""
		
	name = None
	"""The player's name"""
	
	squad = None
	"""The player's squad"""
	
	pid = None
	"""The player's PID, unique for all players in the arena. Invalid after EVENT_LEAVE."""
	
	ship = None
	"""The player's ship, one of SHIP_Xxx.  Use GetShipName() get the ship's name as a string."""

	freq = None
	"""The player's current frequency."""
	
	x_pos = None
	"""The player's X coordinate, in pixels.  This is only as recent as 'last_pos_update_tick."""
	
	y_pos = None
	"""The player's Y coordinate, in pixels.  This is only as recent as 'last_pos_update_tick."""
	
	x_vel = None
	"""The player's X velocity.  This is only as recent as 'last_pos_update_tick."""
	
	y_vel = None
	"""The player's Y velocity.  This is only as recent as 'last_pos_update_tick."""
	
	last_pos_update_tick = None
	"""The tickstamp, in hundreths of seconds, of when the player's last position update was received."""
	
	player_info = None
	"""Reserved for a bot implementation's own use.  Should be set during EVENT_ENTER.
	
	For example:
	
	.. sourcecode:: python
	
		class PlayerInfo:
			def __init__(self):
				self.kill_count = 0
				self.death_count = 0
		
		Then in EVENT_ENTER:
			event.player.player_info = PlayerInfo()
			
		And in EVENT_KILL:
			event.killer.player_info.kill_count += 1
			event.killed.player_info.death_count += 1"""
		
	status_stealth = None
	"""True if the player has stealth on, otherwise False."""
	
	status_cloak = None
	"""True if the player has cloak on, otherwise False."""
	
	status_xradar = None
	"""True if the player has XRadar on, otherwise False."""
	
	status_antiwarp = None
	"""True if the player has AntiWarp on, otherwise False."""
	
	status_flashing = None
	"""I not know what this indicates."""
	
	status_safezone = None
	"""True if the player is in a safe area, otherwise False."""
	
	status_ufo = None
	"""True if the player has UFO toggles, otherwise False."""
	
	def __init__(self, name, squad, pid, ship, freq):
		"""Initialize the Player object."""
		self.name = name
		self.squad = squad
		self.pid = pid
		self.ship = ship
		self.freq = freq
		self.x_pos = -1
		self.y_pos = -1
		self.x_vel = 0
		self.y_vel = 0
		self.last_pos_update_tick = None
		self.player_info = None
		self._setStatus(0x00)
		
	
	def __str__(self):
		return self.name
	
	def _setStatus(self, status_flags):
		"""Updates the player's status with the status flags received in the position update packet."""
		self.status_stealth = status_flags & STATUS_STEALTH != 0
		self.status_cloak = status_flags & STATUS_CLOAK != 0
		self.status_xradar = status_flags & STATUS_XRADAR != 0
		self.status_antiwarp = status_flags & STATUS_ANTIWARP != 0
		self.status_flashing = status_flags & STATUS_FLASHING != 0
		self.status_safezone = status_flags & STATUS_SAFEZONE != 0
		self.status_ufo = status_flags & STATUS_UFO != 0

class Command:
	"""A class that represents a command registered with registerCommand()."""
	
	name = None
	"""The name of the command, such as '!command'."""
	
	id = None
	"""The ID of the command."""
	
	description = None
	"""A short description of thecommand displayed by !help."""
	
	allowed_players = None
	"""A list of players allowed to use the command."""
	
	def __init__(self, name, id, description, allowed_players=None):
		self.name = name
		self.id = id
		self.description = description
		if allowed_players is not None:
			allowed_players = [p.lower() for p in allowed_players]
		self.allowed_players = allowed_players

class Timer:
	"""Represents a timer created with setTimer in the core."""
	
	id = None
	"""The ID of the timer."""
	
	duration = None
	"""The the duration of the timer."""
	
	user_data = None
	"""The user_data value passed in to the setTimer() call when the timer was created."""
	
	base = None
	"""The tickstamp when the timer was created."""
	
	def __init__(self, id, seconds, user_data=None):
		self.id = id
		self.duration = seconds * 100 # to ticks
		self.user_data = user_data
		self.base = GetTickCountHs()

def GetShipName(ship):
	"""Get the name of a ship from a SHIP_Xxx constant."""
	if ship == SHIP_WARBIRD:
		return 'Warbird'
	elif ship == SHIP_JAVELIN:
		return 'Javelin'
	elif ship == SHIP_SPIDER:
		return 'Spider'
	elif ship == SHIP_LEVIATHAN:
		return 'Leviathan'
	elif ship == SHIP_TERRIER:
		return 'Terrier'
	elif ship == SHIP_WEASEL:
		return 'Weasel'
	elif ship == SHIP_LANCASTER:
		return 'Lancaster'
	elif ship == SHIP_SHARK:
		return 'Shark'
	elif ship == SHIP_SPECTATOR:
		return 'Spectator'
	else:
		return 'Unknown'

class SubspaceBot(SubspaceCoreStack.CoreStack):
	"""The bot. Must be connected with connectToServer() and then waitForEvent()
	must be called frequently for adequate performance.
	
	The typical bot's mainloop looks like:
	
	.. sourcecode:: python
	
		while bot.isConnected():
			event = bot.waitForEvent():
			if event.type = ...:
				...
			elif event.type = ...:
				...
	"""
	def __init__(self, owners_list=None, description=None, debug=False):
		"""Initialize the CoreStack class. If debug is set debugging messages will be displayed."""
		CoreStack.__init__(self, debug)
		self.__debug = debug
		self.__players_by_pid = {} # pid : Player
		self.__players_by_name = {} # name: Player
		
		self.__event_list = []
		
		# make the argument into a list if it isnt, xxx, maybe there is a cleaner way to do this
		if type(owners_list) == type(''):
			owners_list = [owners_list]
		self.__owners_list = owners_list
		
		# generate a valid mid
		hash_string = os.name + sys.platform + socket.getfqdn()
		self.machine_id, self.permission_id = struct.unpack_from('II', hashlib.md5(hash_string).digest())
		self.machine_id = self.__makeValidMachineID(self.machine_id)
		
		self.players_here = []
		self.__players_by_name = {}
		self.__players_by_pid = {}
			
		self.__last_event_generated = None
		
		self.pid = None
		self.name = None
		
		self.__cmd_about_description = description
		
		self.arena = None
		
		self.__command_dict = {}
		
		# the ships position data
		self.ship = None
		self.x_pos = 512 * 16
		self.y_pos = 512 * 16
		self.x_vel = 0
		self.y_vel = 0
		self.status = 0
		self.bounty = 0
		self.energy = 0
		self.rotation = 0
			
		self.__timer_list = [] # Timer()
		self.__next_timer_id = 0
		self.__last_timer_expire_tick = GetTickCountHs()
		
		self.__command_die_id = self.registerCommand('!die', 'Stop the bot', owners_list)
		self.__command_help_id = self.registerCommand('!help', 'Show help', None)
		if description:
			self.__command_about_id = self.registerCommand('!about', 'Show information about the bot', None)
		
		#: Event preprocessors can return a new event to pass on to the bot, or None if no event should be generated
		self.__event_preprocessors = {
			EVENT_ENTER : self.__eventEnterPreprocessor,
			EVENT_LEAVE : self.__eventLeavePreprocessor,
			EVENT_TICK :  self.__eventTickPreprocessor,
			EVENT_CHANGE: self.__eventChangePreprocessor,
			EVENT_DISCONNECT : self.__eventDisconnectPreprocessor,
			EVENT_COMMAND : self.__eventCommandPreprocessor,
			EVENT_ARENA_LIST : self.__eventArenaListPreprocessor,
		}
			
		# event post processors
		self.__event_postprocessors = {
			# empty for now
		}
		
		# setup the appropriate handlers
		self.__packet_handlers = {
			0x03 : self.__handlePlayerEnteredPacket,
			0x04 : self.__handlePlayerLeftPacket,
			0x05 : self.__handleLargePositionUpdatePacket,
			0x06 : self.__handleKillPacket,
			0x07 : self.__handleMessagePacket,
			0x0A : self.__handleLoginResponsePacket,
			0x0B : self.__handleGoalPacket,
			0x0D : self.__handleFreqchangePacket,
			0x1C : self.__handleShipChangePacketSelf,
			0x1D : self.__handleShipchangePacket,
			0x27 : self.__handlePositionUpdateRequest,
			0x28 : self.__handleSmallPositionUpdatePacket,
			0x2F : self.__handleArenaListPacket,
			0x31 : self.__handleLoginPacket,
		}
	
	def findPlayerByPid(self, pid):
		"""Find a player by PID.
		
		If a player is not found, None is returned."""
		return self.__players_by_pid.get(pid, None)
	
	def findPlayerByName(self, name):
		"""Find a player by name.
		
		If a player with the exact name is not found, None is returned.""" 
		return self.__players_by_name.get(name.lower(), None)
	
	def registerCommand(self, name, description, allowed_players=None):
		"""Register a command with the core.
		
		name is the name of the command, including the '!'.  description is a short
		one-line explanation of what the command does, displayed in !help.
		
		allowed_players is a list of players who are allowed to use the command. If
		the list is None, then all players are allowed to use it.
		
		Returns a unique identifier for the command, to be used in EVENT_COMMAND
		to identify the command being used."""
		key = name.lower()
		if self.__command_dict.has_key(key):
			raise Exception("Attempt to register already existing command:", name)
		
		id = len(self.__command_dict)
		self.__command_dict[key] = Command(name, id, description, allowed_players)
			
		return id

	def __expireTimers(self):
		"""Expires timers that are in the core's timer list."""
		now = GetTickCountHs()
		self.__timer_list.sort(lambda a, b: int((a.duration - TickDiff(now, a.base)) - (b.duration - TickDiff(now, b.base))))
		
		while self.__timer_list:
			t = self.__timer_list[0]
			if TickDiff(now, t.base) >= t.duration:
				event = GameEvent(EVENT_TIMER)
				event.id = t.id
				event.user_data = t.user_data
				self.__addPendingEvent(event)
				self.__timer_list.pop(0)
			else:
				# since the timer list is sorted the timers after are greater and dont need to be tested
				break

	def setTimer(self, seconds, user_data=None):
		"""Sets a timer that will generate an EVENT_TIMER event in seconds seconds.
		
		user_data is passed back as event.user_data during EVENT_TIMER.
		
		Returns a unique timer id that is passed back in EVENT_TIMER's event.id
		when the timer expires."""
		id = self.__next_timer_id
		self.__next_timer_id += 1
		self.__timer_list.append(Timer(id, seconds, user_data))
		return id
	
	def __makeValidMachineID(self, machine_id):
		"""Generates a valid machine ID."""
		# the mid has to be in a specific format
		mid = array.array('B', struct.pack('<I', machine_id))
		mid[0] = mid[0] % 73
		mid[1] = mid[1] % 129
		mid[3] = (mid[3] % 24) + 7
		return struct.unpack_from('<I', mid.tostring())[0]
	
	def connectToServer(self, hostname, port, username, password, arena='#master'):
		"""Connect to a server using the Subspace protocol.
		
		hostname and port specify the hostname/IP address and port of the server to connect to.  username is
		the user to connect as.  password is the combined password and SMod+ password
		seperated by an asterisk.  For example, 'bot_password*smod_password'. Arena
		is the name of the arena to join upon entering the zone."""
		CoreStack.connectToServer(self, hostname, port)
		self._queueSyncRequest()
		self.flushOutboundQueues()
		self.__queueLoginPacket(username, password)
		self.flushOutboundQueues()
		self.arena = arena
		self.__connected = True
		self.__last_pos_update_sent_tick = GetTickCountHs()
		
		
	def __queueLoginPacket(self, username, password):
		self.queuePacket(struct.pack("<BB32s32sIBhHhIIIIII", 0x09, 0, username, password, self.machine_id, 0, 0, 0x6f9d, 0x86, 444, 555, self.permission_id, 0, 0, 0))
		self.name = username
		
	def __queueArenaLoginPacket(self, arena, ship_type=SHIP_SPECTATOR):
		join_type = 0xFFFD
		if arena.isdigit():
			join_type = int(arena)
		self.queuePacket(struct.pack("<BBHHHH16s", 0x01, ship_type, 0, 4096, 4096, join_type, arena))
	
	def sendArenaMessage(self, message, sound=SOUND_NONE):
		"""Send a message to the arena with an optional sound.
		
		message can be a list of messages to send."""
		if isinstance(message, list):
			for m in message:
				self.__queueArenaMessagePacket(m, sound=sound)
		else:
			self.__queueArenaMessagePacket(message, sound=sound)
		
	def sendPublicMessage(self, message, sound=SOUND_NONE):
		"""Send a public message with an optional sound.
		
		message can be a list of messages to send.
		
		Public messages are sent to the server reliably but may not be relayed
		from the server to all players reliably."""
		if isinstance(message, list):
			for m in message:
				self.__queuePublicMessagePacket(m, sound=sound)
		else:
			self.__queuePublicMessagePacket(message, sound=sound)
		
	def sendFreqMessage(self, freq, message):
		"""Send a freq message.
		
		message can be a list of messages to send."""
		if isinstance(message, list):
			for m in message:
				self.__queueFreqMessagePacket(freq, m)
		else:
			self.__queueFreqMessagePacket(freq, message)
		
	def sendPrivateMessage(self, player, message, sound=SOUND_NONE):
		"""Send a private message to player.
		
		player can be a Player object or the player's name.
		
		message can be a list of messages to send."""
		player_name = player.name if isinstance(player, Player) else player
			
		if isinstance(message, list):
			for m in message:
				self.__queuePrivateMessagePacket(player_name, m, sound=sound)
		else:
			self.__queuePrivateMessagePacket(player_name, message, sound=sound)
		
	def __queueArenaMessagePacket(self, message, sound=SOUND_NONE):
		"""Send message to the arena using arena messages."""
		self.__queuePublicMessagePacket('*arena ' + message, sound=sound);
	
	def __queuePublicMessagePacket(self, message, sound=SOUND_NONE):
		"""Send a message to pub chat in the current arena."""
		self._queueMessagePacket(MESSAGE_TYPE_PUBLIC, message, sound=sound)
	
	def __queuePrivateMessagePacket(self, player_name, message, sound=SOUND_NONE):
		"""Queue a private message to player_name.
		
		If player_name is not in the current arena, the message is sent via remote messages."""
		player = self.findPlayerByName(player_name)
		if player:
			self._queueMessagePacket(MESSAGE_TYPE_PRIVATE, message, target_pid=player.pid, sound=sound)
		else:
			self._queueMessagePacket(MESSAGE_TYPE_REMOTE, ':' + player_name + ':' + message, sound=sound)
	
	def __queueFreqMessagePacket(self, freq, message):
		"""Queue a freq message packet."""
		for p in self.players_here:
			if p.freq == freq:
				self._queueMessagePacket(MESSAGE_TYPE_FREQ, message, target_pid=p.pid)
				break
		
	def _queueMessagePacket(self, message_type, message, target_pid=PID_NONE, sound=SOUND_NONE):
		# this isnt exposed because its a bit too complicated, the simpler calls are exposed that
		# deal with basic message types and are easier to use. lets make this private
		self.queuePacket(struct.pack("<BBBH", 0x06, message_type, sound, target_pid) + message[:247] + '\x00', reliable=True)
		
	def __handleLoginPacket(self, packet):
		self.__queueArenaLoginPacket(self.arena)
		self.flushOutboundQueues()
		self.__addPendingEvent(GameEvent(EVENT_LOGIN))
		
	def __handlePlayerEnteredPacket(self, packet):
		# this should really create a player here dictionary (pid -> player object)
		while len(packet) >= 64:
			unused, ship, unused, name, squad, unused, unused, pid, freq, unused, unused, unused, unused, unused = struct.unpack_from("<BBB20s20sIIHHHHHHB", packet)
			name = name.split(chr(0))[0]
			squad = squad.split(chr(0))[0]
			player = Player(name, squad, pid, ship, freq)
			
			event = GameEvent(EVENT_ENTER)
			event.player = player
			self.__addPendingEvent(event)
			
			packet = packet[64:]
	
	def __handleGoalPacket(self, packet):
		type, freq, points = struct.unpack_from("<BHI", packet)
		event = GameEvent(EVENT_GOAL)
		event.freq = freq
		event.points = points
		self.__addPendingEvent(event)
	
	def __handlePlayerLeftPacket(self, packet):
		# this should really use a player here dictionary and add the player info to the event
		type, pid = struct.unpack_from("<BH", packet)
		player = self.findPlayerByPid(pid)
		if player:
			event = GameEvent(EVENT_LEAVE)
			event.player = player
			self.__addPendingEvent(event)
	
	def __handleLoginResponsePacket(self, packet):
		login_response, = struct.unpack_from("<B", packet, 1)
		if login_response not in [0x00, 0x05, 0x06]:
			raise Exception("Invalid username/password! Error:%d" % login_response)
	
	def __handleShipchangePacket(self, packet):
		type, ship, pid, freq = struct.unpack_from("<BBHH", packet)
		
		player = self.findPlayerByPid(pid)
		if player:
			event = GameEvent(EVENT_CHANGE)
			event.new_freq = freq
			event.new_ship = ship
			event.player = player
			self.__addPendingEvent(event)
	
	def __handleFreqchangePacket(self, packet):
		type, pid, freq, unused = struct.unpack_from("<BHHB", packet)
		
		player = self.findPlayerByPid(pid)
		if player:
			event = GameEvent(EVENT_CHANGE)
			event.new_freq = freq
			event.new_ship = player.ship
			event.player = player
			self.__addPendingEvent(event)
	
	def __handleShipChangePacketSelf(self, packet):
		"""Handle a ship change packet for the bot itself."""
		type, ship = struct.unpack_from("<BB", packet)
		
		player = self.findPlayerByPid(self.pid)
		if player:
			event = GameEvent(EVENT_CHANGE)
			event.new_freq = player.freq
			event.new_ship = ship
			event.player = player
			self.__addPendingEvent(event)
	
	def __handleMessagePacket(self, packet):
		type, message_type, sound, pid = struct.unpack_from("<BBBH", packet)
		
		# add the message event
		message = packet[5:].split(chr(0))[0]
		event = GameEvent(EVENT_MESSAGE)
		event.player = self.findPlayerByPid(pid)
		event.message = message
		event.message_type = message_type
		self.__addPendingEvent(event)
		
		# add the command event
		if len(message) > 0 and message[0] == '!' and message_type in [MESSAGE_TYPE_PUBLIC, MESSAGE_TYPE_PRIVATE]:
			command = message.split()[0]
			arguments = message.split()[1:]
			arguments_after = []
			
			for index in xrange(0, min(8, len(arguments))):
				arguments_after.append(' '.join(arguments[index:]))
				if index > 8: break
			
			player = self.findPlayerByPid(pid)
			if player:
				event = GameEvent(EVENT_COMMAND)
				event.command = command
				event.arguments = arguments
				event.arguments_after = arguments_after
				event.player = player
				
				if message_type == MESSAGE_TYPE_PRIVATE:
					event.command_type = COMMAND_TYPE_PRIVATE
				elif message_type == MESSAGE_TYPE_PUBLIC:
					event.command_type = COMMAND_TYPE_PUBLIC
					
				self.__addPendingEvent(event)
		
	def __handleCommandDie(self, event):
		self.__queuePrivateMessagePacket(event.player.name, "Ok")
		self.disconnectFromServer()
	
	def __handleCommandAbout(self, event):
		self.__queuePrivateMessagePacket(event.player.name, 'About: ' + self.__cmd_about_description)
	
	def __handleCommandHelp(self, event):
		self.__queuePrivateMessagePacket(event.player.name, "Available commands:")
		for k, v in self.__command_dict.iteritems():
			self.__queuePrivateMessagePacket(event.player.name, '%-10s %s' % (v.name, v.description))
	
	
	def __eventEnterPreprocessor(self, event):
			#xxx we should probably make sure the player doesnt already exist here
		player = event.player
		self.__players_by_name[player.name.lower()] = player
		self.__players_by_pid[player.pid] = player
		# make sure player does not already exist in the list
		self.players_here = [p for p in self.players_here if p.pid != player.pid]
		self.players_here.insert(0, player)
		
		if player.name.lower() == self.name.lower():
			self.pid = player.pid
			self.ship = player.ship
			self.freq = player.freq
		
		return event
	
	def __eventLeavePreprocessor(self, event):
		self.__players_by_name.pop(event.player.name.lower(), None)
		self.__players_by_pid.pop(event.player.pid, None)
		self.players_here = [p for p in self.players_here if p.pid != event.player.pid]
		
		return event
			
	def __eventTickPreprocessor(self, event):
		#send pos update
		now = GetTickCountHs()
		#xxx this will need to be changed later if the bot is out of ship (10hs interval if out of ship)
		
		# update position every 10 hs if in ship, otherwise every 1 second
		if self.ship is not None:
			time_period = 100 if self.ship == SHIP_SPECTATOR else 10
			if TickDiff(now, self.__last_pos_update_sent_tick) > time_period:
				self.__queuePositionUpdatePacket()
				self.__last_pos_update_sent_tick = now
		
		if TickDiff(now, self.__last_timer_expire_tick) > 100:
			self.__expireTimers()
			self.__last_timer_expire_tick = now
		
		return event
			
	def __eventChangePreprocessor(self, event):
			# update the players freq and ship
			player = event.player
			
			# if this is the bots own info, update it
			if player.pid == self.pid:
				self.ship = event.new_ship
				self.freq = event.new_freq
			
			new_event = GameEvent(EVENT_CHANGE)
			new_event.player = player
			new_event.old_freq = player.freq
			new_event.old_ship = player.ship
			
			player.ship = event.new_ship
			player.freq = event.new_freq
			
			return new_event
	
	def __eventDisconnectPreprocessor(self, event):
		self.__connected = False
		return event

	def __eventCommandPreprocessor(self, event):
		command = self.__command_dict.get(event.command.lower(), None)
		if command is None:
			# only respond to private message commands
			if event.command_type == COMMAND_TYPE_PRIVATE:
				self.__queuePrivateMessagePacket(event.player.name, "Unknown command")
			return None
		
		new_event = None
		if command.allowed_players is None or event.player.name.lower() in command.allowed_players:
			# this player is allowed to use the command
			new_event = GameEvent(EVENT_COMMAND)
			new_event.player = event.player
			new_event.command = command
			new_event.arguments = event.arguments
			new_event.arguments_after = event.arguments_after
			
			if command.id == self.__command_die_id:
				self.__handleCommandDie(new_event)
			elif command.id == self.__command_help_id:
				self.__handleCommandHelp(new_event)
			elif command.id == self.__command_about_id:
				self.__handleCommandAbout(new_event)
			else:
				event.command = command
		else:
			self.__queuePrivateMessagePacket(event.player.name, "Access denied")
		
		return new_event
			
	def __eventArenaListPreprocessor(self, event):
		#preprocess the negative count
		new_event = GameEvent(EVENT_ARENA_LIST)
		new_event.arena_list = []
		
		for arena, count in event.arena_list:
			if count < 0:
				count = abs(count)
			self.arena = arena
			new_event.arena_list.append((arena, count))
			
		return new_event
	
	def isConnected(self):
		"""Returns True if the bot is connected to the server, otherwise False."""
		return self.__connected
		
	def __handlePositionUpdateRequest(self, packet):
		self.__queuePositionUpdatePacket()
	
	def __queuePositionUpdatePacket(self):
		"""Queue a position update packet to the server."""
		extra_pos_data = 0
		checksum = 0
		packet = struct.pack("<BBIhHBBHhHHH", 0x03, self.rotation, GetTickCountHs(), self.x_vel, self.y_pos, checksum, self.status, self.x_pos, self.y_vel, self.bounty, self.energy, extra_pos_data)
		
		for b in packet:
			checksum ^= ord(b)
		
		packet = packet[:10] + chr(checksum) + packet[11:]
		
		if self.ship is not None and self.ship != SHIP_SPECTATOR:
			# add extra pos data necessary for ships
			packet = packet + '\x00' * 10
		
		self.queuePacket(packet, priority=PRIORITY_HIGH)
	
	def setPosition(self, x_pos=8192, y_pos=8192, x_vel=0, y_vel=0, rotation=0, status_flags=0, bounty=0, energy=0):
		"""Set the bot's coordinates and other position data and send the new position to the server.
		
		status_flags is made of combinations of STATUS_Xxx.
		
		When this is called a packet is queued for send immediately."""
		self.x_pos = x_pos
		self.y_pos = y_pos
		self.x_vel = x_vel
		self.y_vel = y_vel
		self.status = status_flags
		self.bounty = bounty
		self.energy = energy
		self.rotation = rotation
		
		# parameter validation
		if x_pos < 0 or x_pos >= 1024 * 16: raise Exception("Invalid X coordinate: %d" % x_pos)
		if y_pos < 0 or y_pos >= 1024 * 16: raise Exception("Invalid Y coordinate: %d" % y_pos)
		
		self.__queuePositionUpdatePacket()
		self.__last_pos_update_sent_tick = GetTickCountHs()
	
	def requestFreqChange(self, freq):
		"""Sends a freq change request to the server.
		
		Note that until you receive an EVENT_CHANGE update for the bot,
		your freq has not changed."""
		
		packet = struct.pack("<BH", 0x0F, freq)
		self.queuePacket(packet, priority=PRIORITY_HIGH)
	
	def requestShipChange(self, ship_type):
		"""Sends a ship change request to the server.
		
		Note that until you receive an EVENT_CHANGE update for the bot,
		your ship has not changed."""
		
		packet = struct.pack("<BB", 0x18, ship_type)
		self.queuePacket(packet, priority=PRIORITY_HIGH)
		
	def __handleSmallPositionUpdatePacket(self, packet):
		# pos updates dont come for yourself, so this packet does not check against the bot's pid
		type, rotation, timestamp, x_pos, unused, unused, pid, status, y_vel, y_pos, x_vel = struct.unpack_from("<BBHHBBBBhHh", packet)
		player = self.findPlayerByPid(pid)
		if player:
			player.x_pos = x_pos
			player.y_pos = y_pos
			player.x_vel = x_vel
			player.y_vel = y_vel
			player._setStatus(status)
			player.last_pos_update_tick = GetTickCountHs()
			
			event = GameEvent(EVENT_POSITION_UPDATE)
			event.player = player
			self.__addPendingEvent(event)
	
	def __handleLargePositionUpdatePacket(self, packet):
		# pos updates dont come for yourself, so this packet does not check against the bot's pid
		#xxx this packet is actually a lot larger and some fields are ignored here
		type, rotation, timestamp, x_pos, y_vel, pid, x_vel, checksum, status, latency, y_pos = struct.unpack_from("<BBHHhHhBBBH", packet)
		
		player = self.findPlayerByPid(pid)
		if player:
			player.x_pos = x_pos
			player.y_pos = y_pos
			player.x_vel = x_vel
			player.y_vel = y_vel
			player._setStatus(status)
			player.last_pos_update_tick = GetTickCountHs()
			
			event = GameEvent(EVENT_POSITION_UPDATE)
			event.player = player
			self.__addPendingEvent(event)
	
	def __handleKillPacket(self, packet):
		type, unused, killer_pid, killed_pid, unused, unused = struct.unpack_from("<BBHHHH", packet)
		
		killer = self.findPlayerByPid(killer_pid)
		killed = self.findPlayerByPid(killed_pid)
		
		if killer and killed:
			event = GameEvent(EVENT_KILL)
			event.killed = killed
			event.killer = killer
			self.__addPendingEvent(event)
	
	def __handleArenaListPacket(self, packet):
		"""'arenaname\x00\xFF\xFF'"""
		offset = 1 # skip the type byte
		arena_list = []
		while offset < len(packet):
			terminating_null = packet.find('\x00', offset)
			name = packet[offset:terminating_null]
			offset = terminating_null + 1
			count, = struct.unpack_from("h", packet, offset)
			offset += 2
			arena_list.append((name, count))
		
		event = GameEvent(EVENT_ARENA_LIST)
		event.arena_list = arena_list
		self.__addPendingEvent(event)
		
	def waitForEvent(self):
		"""Wait for an event.
		
		A GameEvent class instance is returned, and its type can be found in GameEvent.type.
		The type will be one of EVENT_Xxx.  If the bot is disconnected None will be returned."""
		
		#give the core the chance to post process the last event generated
		if self.__last_event_generated is not None:
			postprocessor = self.__event_postprocessors.get(self.__last_event_generated.type, None)
			if postprocessor:
				postprocessor(self.__last_event_generated)
			self.__last_event_generated = None
			
		if self.__connected is False:
			return None
		
		#xxx make sure large event lists dont starve the core, and i/o should probably be done between events...
		while True:
			if len(self.__event_list) > 0:
				# give the core the chance to preprocess events, this is needed
				# because if the changes were made immediately when the event was received (as opposed to when the packet is removed from queue for processing)
				# the core's view of the game state might be incorrect
				event =  self.__event_list.pop(0)
				preprocessor = self.__event_preprocessors.get(event.type, None)
				if preprocessor:
					event = preprocessor(event)
				if event is None: continue
				self.__last_event_generated = event
				return event
				
			# there are no more bot-level events to process, so call the core's
			# own wait for event handler
			event = CoreStack.waitForEvent(self)
			if event.type == SubspaceCoreStack.EVENT_GAME_PACKET_RECEIVED:
				try:
					game_type, = struct.unpack_from("<B", event.packet)
					handler = self.__packet_handlers.get(game_type, None)
					if handler:
						handler(event.packet)
						
				except (IndexError, struct.error):
					if game_type:
						print 'Structure error in SubspaceBot packet handler: %02X' % game_type
						print event.packet.encode('hex')
						
			# map core stack events to game stack events
			elif event.type == SubspaceCoreStack.EVENT_TICK:
				self.__addPendingEvent(GameEvent(EVENT_TICK))
			elif event.type == SubspaceCoreStack.EVENT_DISCONNECT:
				self.__addPendingEvent(GameEvent(EVENT_DISCONNECT))
				
	def __addPendingEvent(self, game_event):
		self.__event_list.append(game_event)
		
